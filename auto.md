---
# Page settings
layout: default
keywords:
comments: false

# Hero section
title: è‡ªå¾‹èµ°è¡Œ
description: ãƒ­ãƒœãƒƒãƒˆãŒéšœå®³ç‰©ã‚’é¿ã‘ã‚‰ã‚Œã‚‹ã‚ˆã†ã«ã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚

# Author box
# author:
#     title: About Author
#     title_url: '#'
#     external_url: true
#     description: Author description

# Micro navigation
micro_nav: true

# Page navigation
page_nav:
    prev:
        content: 5. ãƒ©ã‚¸ã‚³ãƒ³æ“ä½œ
        url: /remote
    next:
        content: 7. ROSã«ã¤ã„ã¦
        url: /ros
---

# ã‚µãƒ³ãƒ—ãƒ«ãƒ—ãƒ­ã‚°ãƒ©ãƒ 

## ã‚µãƒ³ãƒ—ãƒ«ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰

- åˆ©ç”¨ã™ã‚‹ã‚µãƒ³ãƒ—ãƒ«ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ï¼š`auto/auto.ino`
- ã‚µãƒ³ãƒ—ãƒ«ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ã€**<a href="https://github.com/LifeTechRobotics/secaro_arduino_projects.git" target="_blank" rel="noopener noreferrer">GitHub</a>** ã‚ˆã‚Šãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„ã€‚


## ã‚µãƒ³ãƒ—ãƒ«ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒã§ãã‚‹ã“ã¨

ãƒ­ãƒœãƒƒãƒˆãŒå‰é€²ä¸­ã«ã€**7cmä»¥å†…ã«éšœå®³ç‰©** ã‚’æ¤œçŸ¥ã—ãŸå ´åˆã€è‡ªå‹•çš„ã«å³æ–¹å‘ã¸é€²è·¯ã‚’å¤‰æ›´ã—ã€å›é¿å‹•ä½œã‚’è¡Œã„ã¾ã™ã€‚  
å›é¿ä¸­ã¯ã€å®‰å…¨ã®ãŸã‚ **æœ€å°é€Ÿåº¦** ã§èµ°è¡Œã—ã¾ã™ã€‚  

ã¾ãŸã€ãƒ©ã‚¸ã‚³ãƒ³æ“ä½œã¨åŒæ§˜ã«ã€èµ°è¡Œæ–¹å‘ãŠã‚ˆã³é€Ÿåº¦ã¯ãƒªãƒ¢ãƒ¼ãƒˆã§åˆ¶å¾¡ã™ã‚‹ã“ã¨ãŒå¯èƒ½ã§ã™ã€‚  

## èµ°è¡Œå‹•ç”»

<div style="padding:56.25% 0 0 0;position:relative;"><iframe src="https://player.vimeo.com/video/1101543109?badge=0&amp;autopause=0&amp;player_id=0&amp;app_id=58479" frameborder="0" allow="autoplay; fullscreen; picture-in-picture; clipboard-write; encrypted-media; web-share" style="position:absolute;top:0;left:0;width:100%;height:100%;" title="VID_20250715_142819590"></iframe></div><script src="https://player.vimeo.com/api/player.js"></script>

# è‡ªå¾‹èµ°è¡Œã®å‰æº–å‚™

å‰ç« ã€Œãƒ©ã‚¸ã‚³ãƒ³æ“ä½œã€ã¨åŒæ§˜ã®æ“ä½œç”»é¢ã‚’ä½¿ç”¨ã—ã¦ã€ãƒ­ãƒœãƒƒãƒˆã®è‡ªå¾‹èµ°è¡Œã‚’é–‹å§‹ãƒ»åœæ­¢ã™ã‚‹ãŸã‚ã«ã€äº‹å‰ã«ä»¥ä¸‹ã®æº–å‚™ã‚’è¡Œã£ã¦ãã ã•ã„ã€‚

ğŸ‘‰ **ãƒ©ã‚¸ã‚³ãƒ³æ“ä½œ > [ãƒªãƒ¢ãƒ¼ãƒˆæ“ä½œå‰ã®æº–å‚™](../remote/#%E3%83%AA%E3%83%A2%E3%83%BC%E3%83%88%E6%93%8D%E4%BD%9C%E5%89%8D%E3%81%AE%E6%BA%96%E5%82%99){:target="_blank" rel="noopener noreferrer"}**


# è‡ªå¾‹èµ°è¡Œã•ã›ã¦ã¿ã‚‹

ãƒ©ã‚¸ã‚³ãƒ³æ“ä½œã¨åŒæ§˜ã®æ“ä½œç”»é¢ã‚’ä½¿ã£ã¦ã€ãƒ­ãƒœãƒƒãƒˆã®è‡ªå¾‹èµ°è¡Œã‚’åˆ¶å¾¡ã—ã¾ã™ã€‚  
ã¾ãšã¯ä»¥ä¸‹ã®æ‰‹é †ã§ãƒ­ãƒœãƒƒãƒˆã¨ã®æ¥ç¶šã‚’è¡Œã£ã¦ãã ã•ã„ã€‚

ğŸ‘‰ **ãƒ©ã‚¸ã‚³ãƒ³æ“ä½œ > [ãƒ­ãƒœãƒƒãƒˆã«æ¥ç¶šã™ã‚‹](../remote/#%E3%83%AD%E3%83%9C%E3%83%83%E3%83%88%E3%81%AB%E6%8E%A5%E7%B6%9A%E3%81%99%E3%82%8B){:target="_blank" rel="noopener noreferrer"}**

## èµ°è¡Œé–‹å§‹

ã€Œå‰é€²ã€ãƒœã‚¿ãƒ³ã‚’æŠ¼ã™ã¨ã€ãƒ­ãƒœãƒƒãƒˆã®è‡ªå¾‹èµ°è¡ŒãŒé–‹å§‹ã•ã‚Œã¾ã™ã€‚  
  ![1](../images/auto/up.png)

## èµ°è¡Œçµ‚äº†

ã€Œåœæ­¢ã€ãƒœã‚¿ãƒ³ã‚’æŠ¼ã™ã¨ã€ãƒ­ãƒœãƒƒãƒˆã®èµ°è¡ŒãŒåœæ­¢ã—ã¾ã™ã€‚  
  ![1](../images/auto/stop.png)

# ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°

## ä¾å­˜é–¢ä¿‚

ã“ã®ã‚¹ã‚±ãƒƒãƒã‚’æ­£å¸¸ã«å‹•ä½œã•ã›ã‚‹ãŸã‚ã«ã¯ã€ä»¥ä¸‹ã®ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢ãŠã‚ˆã³ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒå¿…è¦ã§ã™ã€‚


### ä½¿ç”¨ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢

- **M5Atom Liteï¼ˆESP32ãƒ™ãƒ¼ã‚¹ï¼‰**  
  M5Stack ç¤¾è£½ã®å°å‹ãƒã‚¤ã‚³ãƒ³ã€‚Bluetooth é€šä¿¡æ©Ÿèƒ½ã¨ PWM åˆ¶å¾¡æ©Ÿèƒ½ã‚’æŒã¤ ESP32 ã‚’æ­è¼‰ã—ã¦ã„ã¾ã™ã€‚

- **360åº¦é€£ç¶šå›è»¢ã‚µãƒ¼ãƒœãƒ¢ãƒ¼ã‚¿**  
  PWM ä¿¡å·ã®ãƒ‡ãƒ¥ãƒ¼ãƒ†ã‚£æ¯”ã«ã‚ˆã£ã¦å›è»¢é€Ÿåº¦ã¨æ–¹å‘ã‚’åˆ¶å¾¡ã§ãã‚‹ã‚¿ã‚¤ãƒ—ã®ã‚µãƒ¼ãƒœãƒ¢ãƒ¼ã‚¿ã§ã™ã€‚

- **æ¨™æº–ã‚µãƒ¼ãƒœãƒ¢ãƒ¼ã‚¿ Ã— 1ï¼ˆã‚»ãƒ³ã‚µãƒ¼æ—‹å›ç”¨ï¼‰**  
  TOF ã‚»ãƒ³ã‚µãƒ¼ã‚’å·¦å³ã«å‹•ã‹ã™ç”¨é€”ã§ã™ã€‚

- **TOFè·é›¢ã‚»ãƒ³ã‚µãƒ¼ï¼ˆVL53L1Xï¼‰**  
  4cm ã‹ã‚‰ 400cm ã®ç¯„å›²ã§ã€I2C æ¥ç¶šã®ãƒ¬ãƒ¼ã‚¶ãƒ¼è·é›¢ã‚»ãƒ³ã‚µãƒ¼ã§ã™ã€‚


### å¿…è¦ãƒ©ã‚¤ãƒ–ãƒ©ãƒª

- **M5Atom ãƒ©ã‚¤ãƒ–ãƒ©ãƒª**  
  M5.begin() ãªã©ã€M5Atom ã‚·ãƒªãƒ¼ã‚ºå‘ã‘ã®æ©Ÿèƒ½ã‚’æä¾›ã—ã¾ã™ã€‚  
  â€»**Arduino IDE** ã§ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã—ã¦ãŠãå¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚(**Arduino IDEã®å°å…¥ > <a href="../enviroment/#%E3%83%A9%E3%82%A4%E3%83%96%E3%83%A9%E3%83%AA%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB" target="_blank" rel="noopener noreferrer">ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«</a>** )
  
- **esp32-hal-ledc.h**  
  ESP32 ã® PWMï¼ˆLEDCï¼‰åˆ¶å¾¡ã«å¿…è¦ãªãƒ˜ãƒƒãƒ€ãƒ•ã‚¡ã‚¤ãƒ«ã§ã™ã€‚  
  â€»Arduino Core for ESP32 ã«æ¨™æº–ã§å«ã¾ã‚Œã¦ãŠã‚Šã€åˆ¥é€”ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã¯ä¸è¦ã§ã™ã€‚

- **ESP32Servo**  
  æ¨™æº–ã‚µãƒ¼ãƒœãƒ¢ãƒ¼ã‚¿åˆ¶å¾¡ãƒ©ã‚¤ãƒ–ãƒ©ãƒªï¼ˆsensorServo ç”¨ï¼‰ã€‚  
  â€»**Arduino IDE** ã® **ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒãƒãƒ¼ã‚¸ãƒ£** ã‹ã‚‰ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«å¯èƒ½ã§ã™ã€‚  

    ã‚µã‚¤ãƒ‰ãƒãƒ¼ã® **ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼** ã‚’é–‹ãã€æ¤œç´¢æ¬„ã« `ESP32Servo` ã‚’å…¥åŠ›ã—ã€**ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«** ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¾ã™ã€‚  
      ![1](../images/auto/1.png)

- **VL53L1X**  
  TOF è·é›¢ã‚»ãƒ³ã‚µãƒ¼ç”¨ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã€‚Pololu è£½ã€‚  
  â€»**Arduino IDE** ã® **ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒãƒãƒ¼ã‚¸ãƒ£** ã‹ã‚‰ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«å¯èƒ½ã§ã™ã€‚  

    ã‚µã‚¤ãƒ‰ãƒãƒ¼ã® **ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼** ã‚’é–‹ãã€æ¤œç´¢æ¬„ã« `VL53L1X` ã‚’å…¥åŠ›ã—ã¾ã™ã€‚  
    è¤‡æ•°ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒè¡¨ç¤ºã•ã‚Œã¾ã™ãŒã€VL53L1X `by Pololu` ã‚’é¸ã³ã€ **ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«** ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¾ã™ã€‚  
      ![1](../images/auto/2.png)

### ãƒ”ãƒ³è¨­å®š

| æ©Ÿèƒ½              | GPIOãƒ”ãƒ³ |
|-------------------|----------|
| ã‚µãƒ¼ãƒœãƒ¢ãƒ¼ã‚¿1     | 19       |
| ã‚µãƒ¼ãƒœãƒ¢ãƒ¼ã‚¿2     | 22       |
| ã‚»ãƒ³ã‚µãƒ¼ã‚µãƒ¼ãƒœ    | 23       |
| I2C SDAï¼ˆVL53L1Xï¼‰| 26       |
| I2C SCLï¼ˆVL53L1Xï¼‰| 32       |


## setup()

å„ç¨®åˆæœŸåŒ–ã‚’è¡Œã„ã¾ã™ã€‚  
å‰ç« ã¨æ¯”ã¹ã¦ã€éšœå®³ç‰©æ¤œçŸ¥ç”¨ã® TOF ã‚»ãƒ³ã‚µãƒ¼ã¨ã‚»ãƒ³ã‚µãƒ¼ç”¨ã‚µãƒ¼ãƒœã®åˆæœŸåŒ–ãŒè¿½åŠ ã•ã‚Œã¾ã™ã€‚  
ã‚»ãƒ³ã‚µãƒ¼ç”¨ã‚µãƒ¼ãƒœã«ã¯ GPIO ãƒ”ãƒ³ 23 ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚

TOF ã‚»ãƒ³ã‚µãƒ¼ã¯ã€ãƒ­ãƒœãƒƒãƒˆå‰é€²ä¸­ã« **30Â°ã€œ150Â°** ã®ç¯„å›²å†…ã§ã€**500ms ã”ã¨ã« 30Â°ãšã¤**å›è»¢ã—ã¾ã™ã€‚

```cpp
#define PIN_SS 23              // ã‚»ãƒ³ã‚µãƒ¼ã‚µãƒ¼ãƒœ

// ã‚»ãƒ³ã‚µãƒ¼ã‚µãƒ¼ãƒœã®å›è»¢è§’åº¦
#define DEGREE_MIN 30
#define DEGREE_MAX 150

#define INTERVAL_TIME_SS 500         // ã‚»ãƒ³ã‚µãƒ¼ã‚µãƒ¼ãƒœã®å›è»¢é–“éš”
#define OBSTACLE_THRESHOLD 70        // éšœå®³æ¢çŸ¥è·é›¢ï¼ˆmmï¼‰

int deg_step = 30;                   // 1å›ã«ã¤ãã®å›è»¢è§’åº¦

void setup() {
    // ã‚»ãƒ³ã‚µãƒ¼ã‚µãƒ¼ãƒœã®PINè¨­å®š
    sensorServo.attach(PIN_SS);
    sensorServo.write(DEGREE_MIN);

    // TOFã‚»ãƒ³ã‚µãƒ¼ã®åˆæœŸåŒ–
    sensor.setBus(&Wire);
    sensor.setTimeout(TIME_OUT_SENSOR);
    if (!sensor.init()) {
        Serial.println("Failed to initialize sensor.\\n");
    } else {
        sensor.setDistanceMode(VL53L1X::Short);
        sensor.setMeasurementTimingBudget(50000);
        sensor.startContinuous(50); // æ¸¬å®šé–“éš”
    }
}
```

## loop()

**7cm ä»¥å†…ã«éšœå®³ç‰©ãŒæ¤œçŸ¥ã•ã‚ŒãŸå ´åˆ**ã€ãƒ­ãƒœãƒƒãƒˆã¯ **å›é¿ãƒ¢ãƒ¼ãƒ‰** ã«å…¥ã‚Šã¾ã™ã€‚

- å›é¿ãƒ¢ãƒ¼ãƒ‰ä¸­ã¯ã€ä¸€æ™‚çš„ã«å³æ—‹å›ã«åˆ‡ã‚Šæ›¿ãˆ  
- **æœ€å°é€Ÿåº¦ã§ 5000ms èµ°è¡Œ**  
- ãã®å¾Œã€å›é¿ãƒ¢ãƒ¼ãƒ‰ãŒè§£é™¤ã•ã‚Œã€å…ƒã®é€²è¡Œæ–¹å‘ã¨é€Ÿåº¦ã«å¾©å¸°ã—ã¾ã™

```cpp
void loop() {
  if (command == 'F') {
    distance = sensor.read();
    if (distance > 0 && distance < OBSTACLE_THRESHOLD) { // éšœå®³ç‰©ãŒæ¤œçŸ¥ã•ã‚ŒãŸ
      Serial.println("Obstacle detected.\n");

      // å›é¿ãƒ¢ãƒ¼ãƒ‰
      obstacleFlg = true;

      // å›é¿å‰ã®é€Ÿåº¦ã¨æŒ‡ä»¤ã‚’é€€é¿
      spdL_taihi = spdL;
      spdR_taihi = spdR;
      command_taihi = command;

      // å›é¿ä¸­ã¯æœ€å°é€Ÿåº¦
      spdL = 1;
      spdR = 1;

      // å³å›è»¢ã—ã¦å›é¿
      command = 'R';

      // å›é¿å¿…è¦ãªæ™‚é–“
      avoidTimeNeed = 5000; //æš«å®š

      // å›é¿é–‹å§‹æ™‚é–“
      avoidTimeStart = millis();
    } else {
      // å‰é€²
      ledcWrite(PIN_1, centerDutyHigh + step*spdL);
      ledcWrite(PIN_2, centerDutyLow - step*spdR);

      currentMillis = millis();
      if (previousMillis == 0) { // åˆå›ã®å ´åˆ
        previousMillis = currentMillis;
      }
      // å‰é€²æ™‚ã®ã¿ã‚»ãƒ³ã‚µãƒ¼ã‚’å‹•ã‹ã™
      if ((currentMillis - previousMillis) >= INTERVAL_TIME_SS) {
        // ã‚»ãƒ³ã‚µãƒ¼ã‚µãƒ¼ãƒœã®è§’åº¦ã‚’è¨­å®š
        if (ccw) {
          deg += deg_step;
          if (deg >= DEGREE_MAX) {
            deg = DEGREE_MAX;
          }
        } else {
          deg -= deg_step;
          if (deg < DEGREE_MIN) {
            deg = DEGREE_MIN;
          }
        }
        sensorServo.write(deg);
        previousMillis = millis();

        // æ¬¡å›ã®å›è»¢æ–¹å‘ã‚’æ±ºã‚ã‚‹
        if (deg >= DEGREE_MAX) {
          ccw = false;
        } else if (deg <= DEGREE_MIN) {
          ccw = true;
        }
      }
    }
  } else if (command == 'R') {
    if (obstacleFlg) { // å›é¿ãƒ¢ãƒ¼ãƒ‰
      avoidTimeCurrent = millis();
      if ((avoidTimeCurrent - avoidTimeStart) >= avoidTimeNeed) { // å›é¿çµ‚äº†
        obstacleFlg = false;

        // å›é¿å‰ã®é€Ÿåº¦ã«æˆ»ã™
        spdL = spdL_taihi;
        spdR = spdR_taihi;

        // å›é¿å‰ã®æŒ‡ä»¤ã«æˆ»ã™
        command = command_taihi;

        // å›é¿ç”¨å¤‰æ•°åˆæœŸåŒ–
        avoidTimeStart = 0;
        avoidTimeCurrent = 0;
        avoidTimeNeed = 0;
        spdL_taihi = 1;
        spdR_taihi = 1;
        command_taihi = '\0';        
      } else {
        // å³æ—‹å›
        ledcWrite(PIN_1, centerDutyHigh + step*spdL);
        ledcWrite(PIN_2, centerDutyHigh + step*spdR);
      }
    } else {
      // å³æ—‹å›
      ledcWrite(PIN_1, centerDutyHigh + step*spdL);
      ledcWrite(PIN_2, centerDutyHigh + step*spdR);
    }
}

```